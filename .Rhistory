mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette))
mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layers.name = "dd")
mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "dd")
mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12")
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12")
mapshot(m1)
mapshot(m1, url = "/home/csaybar/Desktop/dd/cloudsen12")
library(mapview)
pointss <- st_read("/home/csaybar/Documents/Github/cloudsen12/dataset/data/cloudsen2_potential_points.geojson")
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12")
mapshot(m1, url = "/home/csaybar/Desktop/dd/cloudsen12")
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12", fgb = FALSE)
mapshot(m1,  url = "/home/csaybar/Desktop/dd/cloudsen12")
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12", fgb = T)
mapshot(m1,  url = "/home/csaybar/Desktop/dd/cloudsen12")
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12")
mapviewOptions()
library(mapview)
mapviewOptions(fgb = FALSE)
mapviewOptions(fgb = FALSE)
mapviewOptions()
library(mapview)
mapviewOptions(fgb = FALSE)
m1 <- mapview(pointss, zcol = "type", col.regions = paste0("#", pointss$palette), layer.name = "CloudSEN12")
mapshot(m1,  url = "/home/csaybar/Desktop/dd/cloudsen12")
mapshot(m1,  url = "/home/csaybar/Desktop/dd/index.html")
library(rgee)
# ee_reattach() # reattach ee as a reserved word
ee_Initialize()
# Display the image.
Map$centerObject(image)
Map$addLayer(image, name = "Landsat 8 original image")
# Load an image.
image <- ee$Image("LANDSAT/LC08/C01/T1/LC08_044034_20140318")
# Load an image.
image <- ee$Image("LANDSAT/LC08/C01/T1/LC08_044034_20140318")
# Display the image.
Map$centerObject(image)
m1 <- Map$addLayer(image, name = "Landsat 8 original image")
m1
m1$rgee$tokens
m1 <- Map$addLayer(image, name = "Landsat 8 original image")
m1
class(m1)
m1$rgee$tokens
m1$rgee$tokens
## Not run:
library(rgee)
ee_Initialize(drive = TRUE, gcs = TRUE)
ee_user_info()
# OPTIONAL display it using Map
Map$centerObject(eeObject = img)
Map$addLayer(eeObject = img, visParams = list(max = 0.4,gamma=0.1))
# Define an image.
img <- ee$Image("LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810")$
select(c("B4", "B3", "B2"))$
divide(10000)
# Define an area of interest.
geometry <- ee$Geometry$Rectangle(
coords = c(-110.8, 44.6, -110.6, 44.7),
proj = "EPSG:4326",
geodesic = FALSE
)
# Define an image.
img <- ee$Image("LANDSAT/LC08/C01/T1_SR/LC08_038029_20180810")$
select(c("B4", "B3", "B2"))$
divide(10000)
# Define an area of interest.
geometry <- ee$Geometry$Rectangle(
coords = c(-110.8, 44.6, -110.6, 44.7),
proj = "EPSG:4326",
geodesic = FALSE
)
## drive - Method 01
# Simple
img_02 <- ee_as_raster(
image = img,
region = geometry,
via = "drive"
)
img_02
img_02@history$metadata
knit_with_parameters('~/Desktop/dsadasd.Rmd')
library(reprex)
library(tidyverse)
library(jsonlite)
# test01 -- json format
json_control_1 <- function(metadata_files) {
sapply(
X = metadata_files,
FUN = function(x) tryCatch(
expr = {jsonlite::read_json(x); FALSE},
error = function(e) TRUE
)
) %>% as.logical()
}
#test02 -- empty JSON
json_control_2 <- function(metadata_files) {
lapply(
X = metadata_files,
FUN = function(x) tryCatch(
expr = {jsonlite::read_json(x) %>% names()},
error = function(e) TRUE
)
)
}
#test03 -- Read comments
json_control_3 <- function(metadata_files) {
lapply(
X = metadata_files,
FUN = function(x) tryCatch(
expr = {
x_com <- jsonlite::read_json(x)[["comments"]]
if (x_com == "PUT_HERE_YOUR_COMMENT") {
NULL
} else {
sprintf("%s: %s",basename(x),  x_com)
}
},
error = function(e) TRUE
)
)
}
# duplicated ID?
json_control_4 <- function(metadata_files) {
lapply(
X = metadata_files,
FUN = function(x) tryCatch(
expr = { any(duplicated(names(jsonlite::read_json(x))))},
error = function(e) TRUE
)
) %>% unlist()
}
#TEST ID
metadata_folder <- "metadata/"
setwd("/home/csaybar/Documents/Github/letters/letter_01/")
#TEST ID
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files[json_control_1(metadata_files)]
#TEST NAME
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files %>%
json_control_2 %>%
sapply(function(x) any(grepl("PUT_HERE_ID", x))) %>%
which() -> id_error
metadata_files[id_error]
metadata_files %>%
json_control_2 %>%
sapply(function(x) any(grepl("PUT_HERE_ID", x))) %>%
which() -> id_error
metadata_files[id_error]
#TEST NAME
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files %>%
json_control_2 %>%
sapply(function(x) any(grepl("PUT_HERE_ID", x))) %>%
which() -> id_error
metadata_files[id_error]
#TEST READ_COMMENTS
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files %>%
json_control_3 %>%
unlist()
#TEST DUPLICATED ID
metadata_files[json_control_4(metadata_files)]
#TEST DUPLICATED ID
metadata_files[json_control_4(metadata_files)]
#TEST ID
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files[json_control_1(metadata_files)]
#TEST NAME
metadata_folder <- "metadata/"
metadata_files <- list.files(metadata_folder, full.names = TRUE)
metadata_files %>%
json_control_2 %>%
sapply(function(x) any(grepl("PUT_HERE_ID", x))) %>%
which() -> id_error
metadata_files[id_error]
#' Create image in cloudsen12
#' @author csaybar
#'
#' Script used to manually select images in cloudsen12.
library(tidyverse)
library(googleCloudStorageR)
library(jsonlite)
library(mapview)
library(mapedit)
library(raster)
library(scales)
library(stars)
library(grid)
library(rgee)
library(png)
library(sf)
library(sp)
set.seed(101)
source("src/utils2.R")
ee_Initialize("aybar1994", drive = TRUE, gcs = TRUE)
# 1. Load points with desired cloud average (after run point_creator.R)
local_cloudsen2_points <- read_sf("data/cloudsen2_potential_points.geojson")
# 3. Download images!
jsonfile <- "/home/csaybar/Documents/Github/cloudsen12/dataset/results/metadata_0001.json"
dataset_creator_chips2(
jsonfile = jsonfile,
kernel_size = c(255, 255),
output = "results/"
)
ee_create_cloudseg(path = "/home/csaybar/Documents/Github/cloudsen12/dataset/")
ee_create_cloudseg(path = "/home/csaybar/Documents/Github/cloudsen12/dataset/final_results/cloud-segmentation.json")
ee_create_cloudseg
ee_create_cloudseg <- function(path) {
cseg_list <- list(
name = "cloud-segmentation",
authentication_required = TRUE,
images = list(
path = list(
Sentinel2 = "images/{id}/input.tif",
CloudMask = "images/{id}/target.tif"
),
shape = c(511,511),
thumbnails = "images/{id}/thumbnail.png",
metadata = "images/{id}/metadata.json"
),
segmentation = list(
path = "images/{id}/{id}.png",
mask_encoding = "rgb",
mask_area = c(0, 0, 511, 511),
score = "f1",
pending_threshold = 1,
test_images = NA
),
classes = list(
list(
name = "Clear",
description = "All clear pixels, i.e. without cloud contamination or cloud shadows.",
colour = c(255,255,255,0),
user_colour = c(0,255,255,70)
),
list(
name = "Thick Cloud",
description = "All cloudy pixels covered by thick clouds (does not include semi-transparent clouds or cloud shadows).",
colour = c(255, 255, 0, 70)
),
list(
name = "Thin Cloud",
description = "Clouds that are semi-transparent, i.e. one can see land or sea surfaces through them. If a thin cloud lays over a thick cloud, please paint them with the <i>Thick Cloud</i> class.",
colour = c(0, 255, 0, 70)
),
list(
name = "Cloud Shadows",
description = "All pixels contaminated by cloud shadows (not terrain shadows).",
colour = c(255, 0, 0, 70)
),
list(
name = "No data",
description = "Reserved for no data pixels, e.g. pixels outside of the satellite's swath.",
colour = c(50, 50, 255, 70)
)
),
views = list(
Cirrus = list(
description = "Cirrus and high clouds are red.",
type = "image",
data = "$Sentinel2.B11**0.8*5",
cmap = "jet"
),
cloud_index = list(
description = "Cloud Displacement Index, clouds are red.",
type = "image",
data = "$Sentinel2.B14*-1"
),
"Cirrus-Edges" = list(
"description" = "Edges in the cirrus band",
"type" = "image",
"data" = "edges($Sentinel2.B11**0.8*5)*1.5",
"cmap" = "gray"
),
RGB = list(
"description" = "Normal RGB image.",
"type" = "image",
"data" = c("$Sentinel2.B5", "$Sentinel2.B3", "$Sentinel2.B2")
),
NRGB = list(
description = "Near-Infrared RGB image.",
type = "image",
data = c("$Sentinel2.B5*1.5", "$Sentinel2.B3*1.5", "$Sentinel2.B2*1.5")
),
Edges = list(
description = "Edges in the panchromatic bands",
type = "image",
data = "edges($Sentinel2.B2+$Sentinel2.B3+$Sentinel2.B4)",
cmap = "gray"
),
Snow = list(
description = "Small ice crystals in high-level clouds appear reddish-orange or peach, and thick ice snow looks vivid red (or red-orange). Bare soil appears bright cyan and vegetation seem greenish in the image. Water on the ground is very dark as it absorbs the SWIR and the red, but small (liquid) water drops in the clouds scatter the light equally in both visible and the SWIR, and therefore it appears white. Water Sediments are displayed as dark red.",
type = "image",
data = c("$Sentinel2.B1", "$Sentinel2.B12", "$Sentinel2.B13")
),
"Sentinel-1" = list(
description = "RGB of VH, VV and VH-VV.",
type = "image",
data = c("$Sentinel2.B16", "$Sentinel2.B15", "$Sentinel2.B16-$Sentinel2.B15")
),
Superpixels = list(
description = "Superpixels in the panchromatic bands",
type = "image",
data = "superpixels($Sentinel2.B2+$Sentinel2.B3+$Sentinel2.B4, sigma=4, min_size=100)",
cmap = "jet"
),
Bing = list(
description = "Aerial Imagery",
type = "bingmap"
),
elevation = list(
description = "Elevation values",
type = "image",
data = "$Sentinel2.B18"
),
sen2cloudness = list(
description = "Sen2Cloudness Probability",
type = "image",
data = "$CloudMask.B1"
),
sen2cloudness_reclass = list(
description = "Sen2Cloudness Probability Reclass (BLUE-->CLEAR; RED -> CLOUD)",
type = "image",
data = "$CloudMask.B2"
),
sen2cor = list(
"description" = "sen2cor classes (BLUE--> CLEAR; GREEN -> CLOUD; RED -> CLOUD SHADOW)",
"type" = "image",
"data" = "$CloudMask.B4"
)
),
view_groups = list(
default = c("Cirrus", "RGB", "Snow")
)
)
jsonlite::write_json(
x = cseg_list,
path = path,
pretty = TRUE,
auto_unbox = TRUE
)
}
ee_create_cloudseg
ee_create_cloudseg(path = "/home/csaybar/Documents/Github/cloudsen12/dataset/final_results/cloud-segmentation.json")
#' Create image in cloudsen12
#' @author csaybar
#'
#' Script used to manually select images in cloudsen12.
library(googleCloudStorageR)
library(googledrive)
library(tidyverse)
library(jsonlite)
library(mapview)
library(mapedit)
library(raster)
library(scales)
library(stars)
library(purrr)
library(grid)
library(rgee)
library(png)
library(sf)
library(sp)
set.seed(101)
source("src/utils.R")
ee_Initialize("aybar1994", drive = TRUE, gcs = TRUE)
# 1. Load points with desired cloud average (after run point_creator.R)
local_cloudsen2_points <- read_sf("data/cloudsen2_potential_points.geojson")
# 3. Download images!
jsonfiles <- list.files(
path = "/home/csaybar/Documents/Github/cloudsen12/dataset/results/",
pattern = "\\.json$",
recursive = TRUE
)
jsonfiles
# 1. Libraries
library(googleCloudStorageR)
library(googledrive)
library(tidyverse)
library(jsonlite)
library(mapview)
library(mapedit)
library(raster)
library(scales)
library(stars)
library(purrr)
library(grid)
library(rgee)
library(png)
library(sf)
library(sp)
source("src/utils.R")
# 2. Initialize Earth Engine
ee_Initialize("aybar1994", drive = TRUE, gcs = TRUE)
# 3. Load points with desired cloud average (after run point_creator.R)
local_cloudsen2_points <- read_sf("data/cloudsen2_potential_points.geojson")
# 5. List all the metadata
jsonfiles <- list.files(
path = "/home/csaybar/Documents/Github/cloudsen12/dataset/results/",
pattern = "\\.json$",
recursive = TRUE
)
jsonfiles
### Prepare data for iris ------------------------
output_final <- "final_results/"
output_final_d <- sprintf("%s/images", output_final)
output_final_d
dataset_creator_chips <- function(jsonfile,
kernel_size = c(255, 255),
output_final = "final_results/") {
# 1. Read JSON file
jsonfile_r <- jsonlite::read_json(jsonfile)
# 2. Create a point which represent the center of the chip
st_point <- st_sfc(geometry = st_point(c(jsonfile_r$x, jsonfile_r$y)), crs = 4326)
point <- ee$Geometry$Point(jsonfile_r$x, jsonfile_r$y)
# 3. Identify all the S2 images
s2_ids <- sprintf("COPERNICUS/S2/%s", names(jsonfile_r)[1:5])
# s2_id <- s2_ids[2]
# 3. Download each image at each point
for (s2_id in s2_ids) {
message(sprintf("Downloading: %s", s2_id))
# 3.1 S2 ID and dates
s2_img <- ee$Image(s2_id)
# Map$centerObject(point)
# map02 <- Map$addLayer(s2_img, list(min=0, max=10000, bands = c("B4","B3","B2"))) +
# Map$addLayer(point)
s2_date <- ee_get_date_img(s2_img)[["time_start"]]
# 3.2 S1 ID and dates
s1_id <- ee_get_s1(point = point, s2_date = s2_date)
s1_img <- ee$Image(s1_id)
# Map$addLayer(s1_img)
# 3.3 Create a S2 Image with cloud mask information
s2_fullinfo <- ee_merge_s2_full(s2_id, s1_id, s2_date)
crs_kernel <- s2_fullinfo$select(0)$projection()$getInfo()$crs
point_utm <- st_transform(st_point, crs_kernel)
ee_point <- ee$Geometry$Point(point_utm[[1]], proj = crs_kernel)
# 3.4 Create a 511x511 tile
band_names <- c(s2_fullinfo$bandNames()$getInfo(), "x", "y")
s2_img_array <- s2_fullinfo$addBands(s1_img) %>%
ee$Image$addBands(ee$Image$pixelCoordinates(projection = crs_kernel)) %>%
ee$Image$neighborhoodToArray(
kernel = ee$Kernel$rectangle(kernel_size[1], kernel_size[2], "pixels")
) %>%
ee$Image$sampleRegions(ee$FeatureCollection(point),
projection = crs_kernel,
scale = 10) %>%
ee$FeatureCollection$getInfo()
extract_fn <- function(x) as.numeric(unlist(s2_img_array$features[[1]]$properties[x]))
image_as_df <- do.call(cbind,lapply(band_names, extract_fn))
colnames(image_as_df) <- band_names
image_as_tibble <- as_tibble(image_as_df)
coordinates(image_as_tibble) <- ~x+y
sf_to_stack <- function(x) rasterFromXYZ(image_as_tibble[x])
final_stack <- stack(lapply(names(image_as_tibble), sf_to_stack))
crs(final_stack) <- st_crs(crs_kernel)$proj4string
### Prepare data for iris ------------------------
output_final_d <- sprintf("%s/images", output_final)
output_final_folder <- sprintf("%s/images/%s", output_final, basename(s2_id))
metadata_final <- sprintf("%s/cloud-segmentation.json", output_final)
metadata_spec <- sprintf("%s/images/%s/metadata.json", output_final, basename(s2_id))
inputdata_spec <- sprintf("%s/images/%s/input.tif", output_final, basename(s2_id))
cloudmask_spec <- sprintf("%s/images/%s/target.tif", output_final, basename(s2_id))
dir.create(output_final, showWarnings = FALSE)
dir.create(output_final_d, showWarnings = FALSE)
dir.create(output_final_folder, showWarnings = FALSE)
# Create JSON
ee_create_cloudseg(path = metadata_final)
ee_create_metadata(
id = basename(s2_id),
point = c(jsonfile_r$y, jsonfile_r$x),
path = metadata_spec
)
nlen <- length(names(final_stack))
input_data <- raster::stack(
final_stack[[1:13]]/10000, final_stack[[14]], final_stack[[15:17]], final_stack[[22:23]]
)
# 18-19 -> cmask_s2cloudness| cmask_s2cloudness_reclass (0,1)
# 20-21 -> cmask_sen2cor | cmask_sen2cor_reclass (0,1,2)
benchmarch_data <- final_stack[[18:21]]
writeRaster(x = input_data, filename = inputdata_spec, overwrite = TRUE)
writeRaster(x = benchmarch_data, filename = cloudmask_spec, overwrite = TRUE)
}
}
# 1. Libraries
library(googleCloudStorageR)
library(googledrive)
library(tidyverse)
library(jsonlite)
library(mapview)
library(mapedit)
library(raster)
library(scales)
library(stars)
library(purrr)
library(grid)
library(rgee)
library(png)
library(sf)
library(sp)
source("src/utils.R")
# 2. Initialize Earth Engine
ee_Initialize("aybar1994", drive = TRUE, gcs = TRUE)
# 3. Load points with desired cloud average (after run point_creator.R)
local_cloudsen2_points <- read_sf("data/cloudsen2_potential_points.geojson")
